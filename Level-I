# Q1
# Расскажите, чем, на ваш взгляд, отличается хорошее клиентское приложение от
# плохого с точки зрения:
• пользователя;
- Понятным интерфейсом
• менеджера проекта;
- Удобством оперативного изменения каккой-либо части
• дизайнера;
- Понятным интерфесом, порядком построения композиции и красивыми, гармоничными цветами
• верстальщика;
- Стилем верстки, Понятностью архитектуры тегов, порядком построения композиции 
• серверного программиста. 
- Наименьшим исползованием места сервера.

# Q2
# Опишите основные особенности разработки крупных многостраничных сайтов,
# функциональность которых может меняться в процессе реализации и поддержки.
# Расскажите о своем опыте работы над подобными сайтами: какие подходы,
# инструменты и технологии вы применяли на практике, с какими проблемами
# сталкивались и как их решали

Особенности:
- Единость стиля 
- Единость "шаблона"(меню, "шапка", "подвал")
- Отдельность каждого "модуля" для оперативной замены его функциональности, внешнего вида и т.д.

В создании крупных многостраничных сайтов у меня возникла только одна проблема(Моя лень). 
Мне было лень в каждую страницу вставлять меню и шапку(около 7-10 строчек кода) и я решил создать
js файл который сам добавляет их(меню и шапку) в начало тела(тега body). Применял JQuery, JQuery UI,
SublimeText, Адаптивную верстку(в итоге работала неправильно и я ее убрал), 

# Q3 
# При разработке интерфейсов с использованием компонентной архитектуры часто
# используются термины Presentational Сomponents и Сontainer Сomponents. Что
# означают данные термины? Зачем нужно такое разделение, какие у него есть
# плюсы и минусы? 

Нет ответа

# Q4
# Как устроено наследование в JS? Расскажите о своем опыте реализации JS наследования
# без использования фреймворков. 

childObjetct<-parentObject(наследование объектов):
childObjetct.__proto__ = parentObject;

childClass<-parentObject(наследование классов у объектов):
childClass.prototype = parentObject;

childClass<-parentClass(наследование классов):
childClass.prototype = Object.create(parentClass.prototype);

Один раз на собеседовании пригодилось
